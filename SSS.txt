1) Introduction to Microkernels
	1) Каким образом реализована идея “Everything is Object”, в чем этом выражается?
		Вся система (набор ресурсов и абстракций) представляется пользовательской задаче как набор объектов, где ядро играет роль посредника между взаимодействуюшими объектами, а также предоставляет возможность создавать и разрушать объекты.
	2) Что такое Capability list, зачем он нужен?
		Capability List - это грубо говоря массив в пространстве ядра, который хранит capabilities, которые в свою очередь являются ссылками на объекты с которыми разрешено взаимодействие со стороны задачи, которой принадлежит этот list. User mode приложение указывает объект над которым, оно хочет произвести действие за счет указания индекса объекта в Capability List. Capability List - это механизм контроля взаимодействия между объектами.
	3) Где находится scheduler и почему?
		Планировщик реализуется в самом ядре, хотя это и нарушает принцип согласно которому "all polocies must be outside of the kernel". Насколько мне известно, в рамках проета L4 производились попытки выноса планировщика в User Mode, однако в результате это приводило к катастрофическому падению производительности системы. В связи с этим планировщик остался в ядре.
	4) Что такое Sigma0, Moe, Ned, и зачем они нужны?
		Sigma0 - это основной менеджер памяти системы создаваемый загрузчиком и владеющий начальным идемпонентным адресным пространством, которое отображает всю физическую память системы.
		Moe - это первая задача, которая обычно запускается в L4Re-системе. Moe запускается как корневая задача и предоставляет реализацию используемую по умолчанию для базовых абстракций L4Re.
		Ned - это bootstrap модуль для L4. Нужен для координации запуска служб и приложений и предоставления коммуникационного канала используемого ими. 
	5) Что собой представляет L4Re?
		L4Re расшифровывается как L4 Runtime Environment и представляет собой нобор библиотек и сервисов, которые в совокупности с ядром образуют базовую операционную систему. Так как L4 по сути представляет минимизированное ядро он нуждается в наличии L4Re для реализации операционной системы.
	6) Что является execution unit в концепции Fiasco.OC ?
		Thread является execution unit в среде L4 подобно тому как это реализовано и в других ОС. Основное отличие L4 состоит в том, что поток в L4 редуцирован.
	7) Что такое TCB, чет отличается от UTCB, что такое Kernel Info Block, где находится каждая из этих структур, зачем она нужна и как с ними можно работать?
		Каждый поток имеет свой собственный набор виртуальных регистров называемых Thread Control Registers (TCR). Эти виртуальные регистры являются статическими и хранят состояние потока (например, параметры IPC, параметры планирования, идентификатор потока и т.п.). TCR находятся в области адресного пространства называемой Thread Control Block (TCB). TCB фактически разделен на две части, пользовательcкий TCB (User TCB, UTCB), к которому имеет доступ пользовательское приложения, и ядерный TCB (Kernel TCB, KTCB), доступ к которому имеет только ядро. Программистов, как правило, интересует только UTCB, к которму у программистов есть полный доступ. Ограниченный доступ к KTCB можно получить за счет системных вызовов.
		Kernel Info Block, который также называется Kernel Information Page представляет собой специальную страницу памяти отображаемую в каждое виртуальное адресное пространство по фиксированному адрессу в режиме только чтения и хранит общую информацию о среде выполнения, которая может быть интересна программом выполняющимся в этой среде. KIP статическая структура данных, которая не изменяется.
	8) Какие механизмы сериализации доступа к переменным были озвучены в лекции?
		a) cli/sti (отключение приема запросов на прерывание)
		б) spinlock-и
		в) blocking lock (pthread_mutex)
		г) serializing thread
	9) Что делает и зачем нужны l4_msgtag и l4_ipc_send?
		l4_msgtag представляет собой так называемый message tag, который является обязательной частью сообщения. Message tag содержит управляющую информацию о сообщении (размер сообщения и вид содержащихся в нем данных) и метку сообщения (служит для идентификации сообщения на стороне прикладной программы (часто содержит id запроса или номер запрашиваемой функции)).
		l4_ipc_send - это обертка над capability invocation обозначающем отправку извещания (отправили и продолжили работать без ожидания ответа).
2) Ipc, Memory and L4Re
	1) Что такое factory, каким образом используется и для чего?
		factory - это абстракция L4 (ядерный объект) с помощью которой создаются ядерные объекты всех видов (factory, task, thread, gate, irq, vm) и осуществляется контроль над созданием новых ядерных объектов. Типичное использование предполагает два шага: 1) получение factory с помощью L4Re и 2) создание нового объекта через соответствующий вызов factory.
	2) Что такое target_cap, thread_cap? Область видимости gate.
		target_cap - это идентификатор capability, которая будет использоваться как корневая capability для IPC gate. С помощью этой capability мы сможем обращаться к IPC gate после его создания.
		thread_cap - это идентификатор потока, к которому будет привязан IPC gate. То есть того, потока который сможет получать сообщения из создаваемого канала IPC. Область видимости gate: явная - каждый поток, который имеет capability соответствующего gate. Неявно - поток, к которому привязан gate и поток получатель имеет capability на gate привязанный к потоку отправителю сообщения начиная с момента получения сообщения и заканчивая моментом запроса на получение следующего сообщения.
	3) Структура utcb и назначение каждого из полей.
		Message virtual regsters - используются для передачи параметров при системных вызовах и для передачи сообщений при IPC
		Buffer registers - используются для хранения дескрипторов flexpage.
		Thread Control registers - используется для хранения приватных данных потоков.
	4) Что происходит, когда истекает timout в ipc?
		Происходи возврат в точку вызовы с кодом L4_IPC_RETIMEOUT или L4_IPC_SETIMEOUT обозначающим завершение операции по таймауту.
	5) Есть ли ограничения на длинну ipc message?
		Есть ограничение на количество используемых виртуальных регистров UTCB [0;63] и количества flexpage [0; 63] используемых для передачи сообщения.
	6) Что такое IDL compiler, зачем он нужен и какие проблемы решает?
		Это специальный компилятор (расширение компилятора) используемый для генерации комменикационного кода в соотвествии с метаописанием прототипа функции. Используется для преобразования привычного нам function call кода в message passing код. Подход был впервые применен в рамках проекта Mach, для которого был разработан IDL компилятор MIG (Mach Interface generator). Основные задачи решаемые IDL компилятором: автоматизация задач создания кода для обмена сообщениями. Делает разработку сервисов независимой от ABI целевой платформы.
	7) Как эти проблемы решены в gnu/mach (вдруг вы знаете), как он решаются в l4re?
		По-поводу GNU/Mach cмотри в предыдущий ответ. Свято верю, что они используют MIG, вероятно немного доработанный/переделанный. Судя по лекции, L4Re шел аналогичным путем, но в связи с административными проблемами проет был замороен. Однако, в рамках L4Re была разработана и применяется Stream Library основанная на идее использования операторов потока С++ для аналогичных целей.
	8) Communication channel и ipc gate - одно и то же?
		Comunication channel это представление ipc gate в Lua скрипте используемом Moe. Основное отличие заключается в том, что Comunication channel представляет непривязанный ipc gate.
	9) Так все же, каким образом сервер узнают какую dispatch функцию вызывать?
		Полиморфизм. Когда мы наследуемся от L4::Server мы неявно указываем адресс функции Disatch которая определяется нашим классом и будет вызываться в главном внутреннем цикле сервера в ответ на получение сообщения.
	10) А если у нас несколько каналов?
		Тогда нам нужер строить наше приложение на основе L4::basic_regestry. Оборачивать каждый ipc gate в Server_object и регистрировать в basic_regestry с указанием метки. В результате, приполучении сообщения basic_regestry извлечет из сообщения метку, найдет объект который сопоставлен с этой меткой и вызовет его функцию dispatch.
	11) Опишите пожалуйста механизм работы sigma0, каким образом обрабатываются page fault?
		Каждый поток в системе связан с двумя специальными потоками - обработчиком отказа страницы и обработчиком исключения. В том случае, если выполнение потока вызывает отказ страницы, он перехватывается в ядре и деспетчеризуется с помощью IDT на специальную функцию обработчик в ядре. Данный обработчик, определяет pager присвоеный вызвавшему отказ потоку и отправляет ему сообщение с описанием отказа (адрес, тип нарушения). pager производит необходимую обработку (отображает физическую память на область адресов вызвавшую отказ с помощью какого-либо менеждера памяти (например Sigma0)).
	12) У каждого треда есть pager - обработчик page fault.
		Нет не у каждого. Пример Sigma0.
	13) Что такое flexpage и зачем это нужно?
		flexpage - это обобщение понятия страницы физической памяти. flexpage представляет область памяти заданную начальным адресом (выровнен на размер flexpage), размером (sizeof(flexpage) = 2^n, sizeof(flexpage) >= 1024, sizeof(flexpage) >= sizeof(hardware page)) и правами доступа. Для того чтобы дать доступ к области памяти задаваемой flexpage-ем какому-либо потоку flexpage должен быть помещен в MapItem и этот MapItem должен быть отправлен целевому потоку. При получении такого сообщения, ядро автоматически отображает область памяти заданную flexpage в адресное пространство получателя.
	14) Опишите пожалуйста проблему иерархических мапингов и метод ее решения в fiasco.oc
		Проблема заключается в том, что в одну и ту же task может отображаться память нескольких pager-oв. В тако случае возникает неопределенность при отказе страницы, какому pager-у отправлять сообщение об отказе. Проблема решена за счет введения дополнительной сущности - Region Mapper. У каждого task есть свой назначенный region mapper, который получает извещения обо всех отказах страниц произошедших в данной task и перенаправляет их другим pager-ам в соответствии с картой адресного пространства, которую он поддерживает.
	15) Что такое dataspace, каким образом с этой абстракцией осцществляетс работа?
		dataspace - это общая абстракция памяти и отображения памяти. Приложение может получать capability для dataspace своей task и запрашивать у region mapper-а добавление и удаление dataspace-ов. В случае возникновения отказа в пределах dataspace, сообщение будет отправляться pager-у отвественому за данный dataspace.
	16) Как используя dataspace передавать данные между серверами.
		1) Вставяем dataspace в исходный task.
		2) исходный таск заполняет его данными и отправляет сообщение pager-у ответственному за данный dataspace с просьбой передать его целевой задаче. 
		3) pager - удаляет dataspace из исходного task и прикрепляет его к целевому task.
		4) pager извещает целевой thread выполняющийся в контексте целевой task о прибытии данных
		5) целевой таск читает данные.
		

3) Advanced Components
	1) Опишите пожалуйста подходы к адаптации/использованию
		Портирование. Переписывание приложения с целью использования нового ABI (L4 && L4Re) вместо старого (Linux, Windows etc.)
		Перехват на уровне библиотек. Переписывание популярных библиотек под L4 и перекомпиляция существующих программ с использованием портированных библиотек.
		Перехват на уровне ядра. Перехват в точке системного вызова (в ядре) и перенаправление в среду L4.
		Виртуальные машины. L4 в роли гипервизора а-ля VmWare ESX Server.
		В рамках лекции было показано, что портирование Linux приложений наиболее оправдано за счет реализации POSIX интерфейса в  среде L4.
	2) Продемонстриуйте пожалуйста, на примере любой функции POSIX (кроме time)
		#include <l4/re/env.h>
		#include <l4/sys/ipc.h>
		
		int putchar(int c)
		{
			char str[2];
			int  retcode = 0;
			
			str[0] = c;
			str[1] = '\0';
			
			l4_utcb_mr()->mr[0] = L4_VCON_WRITE_OP;
			l4_utcb_mr()->mr[1] = 2;
			memcpy(&l4_utcb_mr()->mr[2], str, 2);
			
			if (l4_msgtag_has_error(l4_ipc_send(l4re_env()->log, l4_utcb(), l4_msgtag(L4_PROTO_LOG, 3, 0, L4_IPC_NEVER))))
			{
				retcode = -1;
			}
			
			return retcode;
		}
	3) Объясните пожалуйста плюсы и минусы переноса драйвера в usespace
		+: отказоустойчивость (упал драйвер - перезапустили драйвер / в монолите - упала вся система)
		+: простота разработки (можно использовать привычные всем библиотеки/сервисы, API)
		+: простота отладки (также как и обычное приложение)
		-: накладные расходы на взаимодействие и переключение контекстов.
		-: вероятно увеличивающаяся латентность
		-: вероятно увеличение степени временной непредсказуемости
	4) Каким образом обрабатываются прерывания в системе?
		L4 позволяет задаче слушать систему на предмет определенных IRQ. При получении прерывания последнее концертируется в сообщение и отправляется слушателю. Слушатель получает сообщение и производит требуемые действия в ответ.
	5) Каким образом ядро предоставляет доступ пользовательским приложениям к портам ввода-вывода?
		За счет I/O flexpages.  I/O flexpages работают по отношению к адресному пространству портов так же как и flexpages по отношению к физическому адресному пространству. При переключении виртуальных адресных проств, ядро так же переключает и адресные пространства портов.
	6) Каким образом память устройств отображаются в пространство драйвера?
		Так же как и обычная память. Я вообще склонен рассматривать физическое адрессное пространство как отдельную сущность, а не как память.
Различные диапазоны физических адресов могут быть или не быть связаны с внешними ресурсами такими как RAM, ROM, Device Registers etc.
	7) Что такое virtual pci buss и каким образом работает?
		Это виртуализация шины PCI, поддерживаемая сервером ввода/вывода, которая содержит только те устройства и функции, которые нужны определенному драйверу. Таким образом, misbeving драйвер не может интерферировать с другими драйверами ошибочно програмируя "чужое" устройство.
	8) Что такое DDE/Linux, DDEkit, что собой представляют, как работают?
		DDE/Linux - это среда для драйверов устройств Linux для L4. В частности, это набор библиотек реализующих интерфейсы определенных подсистем ядра Linux, позволяющий программисту выбрать какая часть ядра нужна для определенного драйвера и подключить соответствующий слой эмуляции к драйверу.
		DDEKit - это надкласс по отношению к DDE/Linux, который реализует набор DDE сред различных операционых систем.
		Принцип работы - перехват запросов отправляемых драйвером к интерфейсу родной для него ОС эмулируемой средой DDE и их перенаправление на аналогичные системы L4.
	9) Каким образом решена проблема множественного доступа к устройствам?
		За счет дополнительного слоя виртуализации, состоящего из двух частей: виртуального устройства, каждое из которых назначается отдельной задаче и слоя мультиплексирования, который осуществляет корректное разделение нижележащего физического устройства между множеством виртуальных устройств.
	10) Что такое паравиртуализация?
		Паравиртуализация — это техника виртуализации, в соответствии с которой ядро гостевых операционных систем незначительно модифицируется для исполнения в виртуализированной среде, таким образом, что ряд низкоуровневой функциональности ядра системы заменяется вызовами гипервизора. 
	11) Как разделены адресные пространства ядра и прикладных программ l4linux
		Если я правильно помню, то ядро выполняется как отдельный task, а в linux приложение вместо ядра вставляется заглушка которая преобразует системные вызовы сделанные приложением в сообщения направляемые в task реализующую ядро Linux.
	12) Как работают системные вызовы между прикладными программами и l4linux ядром
		Смотри предыдущий ответ.
	13) Что такое vCPU? как он реализован?
		Дополнительная абстракция. Служит для упрощения реализации L4Linux. vCpu представляет собой элемент планирования с двумя контекстами: kernel и user и механизмом посредничества меду ними. В результате vCpu может рассматриваться как абстракция виртуальной машины с гостевой ОС. Но в то же время, он остается простым Thread с точки зрения планировщика системы, что позволяет справедливо разделять ресурсы системы между виртуальными машинами не зависимо от того, сколько задач выполняется в их контексте.